Index: clause_dynamique.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from pprint import pprint\r\nfrom time import sleep\r\nfrom typing import List, Tuple\r\nimport subprocess\r\nfrom itertools import combinations\r\n\r\nfrom test_clause_hitman import *\r\nGrid = List[List[int]]\r\nPropositionnalVariable = int\r\nLiteral = int\r\nClause = List[Literal]\r\nClauseBase = List[Clause]\r\nModel = List[Literal]\r\n\r\n\r\ndef ecouter(i,j,m,n, matrice,dict_var_to_num) : # ici (0,0) = coin inferieur gauche\r\n    r = []\r\n    variables = []\r\n    k = 0\r\n    if i == 0 :\r\n        if j == 0 : # coin inférieur gauche\r\n            for a, b in combinations([1,0],2) :\r\n                if (matrice[a][b] == \"G\" or matrice[a][b] == \"I\") :\r\n                    k+= 1\r\n                variables.append(f\"{a}{b}_P\")\r\n        elif j == m : # coin inférieur droit\r\n            for a in range(0,1) :\r\n                for b in range(m-1,m) :\r\n                    if (matrice[a][b] == \"G\" or matrice[a][b] == \"I\"):\r\n                        k += 1\r\n                    variables.append(f\"{a}{b}_P\")\r\n        else :\r\n            for a in range(0,1) :\r\n                for b in range(j-1,j+1) :\r\n                    if (matrice[a][b] == \"G\" or matrice[a][b] == \"I\"):\r\n                        k += 1\r\n                    variables.append(f\"{a}{b}_P\")\r\n    elif i == n :\r\n        if j == 0 :  # coin supérieur gauche\r\n            for a in range(n-1,n) :\r\n                for b in range(0,1) :\r\n                    if (matrice[a][b] == \"G\" or matrice[a][b] == \"I\"):\r\n                        k += 1\r\n                    variables.append(f\"{a}{b}_P\")\r\n        elif j == m : # coin supérieur droit\r\n            for a in range(n-1,n) :\r\n                for b in range(m-1,m) :\r\n                    if (matrice[a][b] == \"G\" or matrice[a][b] == \"I\"):\r\n                        k += 1\r\n                    variables.append(f\"{a}{b}_P\")\r\n        else :\r\n            for a in range(n-1,n) :\r\n                for b in range(j-1,j+1) :\r\n                    if (matrice[a][b] == \"G\" or matrice[a][b] == \"I\"):\r\n                        k += 1\r\n                    variables.append(f\"{a}{b}_P\")\r\n    else :\r\n        for a in range(i-1, i+1):\r\n            for b in range(j - 1, j + 1):\r\n                if (matrice[a][b] == \"G\" or matrice[a][b] == \"I\"):\r\n                    k += 1\r\n                variables.append(f\"{a}{b}_P\")\r\n    for elt in variables :\r\n        r.append(dict_var_to_num[elt])\r\n    return exactly_k(k,r)\r\n\r\ndef voir(i,j,m,n,orientation,matrice,dict_var_to_num) :\r\n    r = []\r\n    variables = []\r\n    if orientation == \"E\"  :\r\n        if j == m : # Si face a la bordure de droite on ne fait rien\r\n            return\r\n        if matrice(i,j+1) != \"V\" and j+1<=m : # Si la case d'après est non vide\r\n            variables.append(matrice(i,j+1)) # ou modifier la matrice dynamique ( pas \"matrice\", la deuxieme vide qui se remplit au fur et a mesure )\r\n        elif matrice(i,j+2) != \"V\" and j+2<=m:\r\n            variables.append(matrice(i, j + 1))\r\n            variables.append(matrice(i, j + 2))\r\n        elif matrice(i,j+3) != \"V\" and j+3<=m:\r\n            variables.append(matrice(i, j + 1))\r\n            variables.append(matrice(i, j + 2))\r\n            variables.append(matrice(i, j + 3))\r\n        else :        # Si toute les cases ( 3 ) sont vides\r\n            variables.append(matrice(i, j + 1))\r\n            variables.append(matrice(i, j + 2))\r\n            variables.append(matrice(i, j + 3))\r\n    elif orientation == \"O\"  :\r\n        if j == 0 :\r\n            return\r\n        if matrice(i,j-1) != \"V\" and j-1>=0 :\r\n            variables.append(matrice(i,j-1))\r\n        elif matrice(i,j-2) != \"V\" and j-2>=0:\r\n            variables.append(matrice(i, j - 1))\r\n            variables.append(matrice(i, j - 2))\r\n        elif matrice(i,j-3) != \"V\" and j-3>=0:\r\n            variables.append(matrice(i, j - 1))\r\n            variables.append(matrice(i, j - 2))\r\n            variables.append(matrice(i, j - 3))\r\n        else :\r\n            variables.append(matrice(i, j - 1))\r\n            variables.append(matrice(i, j - 2))\r\n            variables.append(matrice(i, j - 3))\r\n    elif orientation == \"S\":\r\n        if i == 0 :\r\n            return\r\n        elif matrice(i-1,j) != \"V\" and i-1>=0 :\r\n            variables.append(matrice(i-1,j))\r\n        elif matrice(i-2,j) != \"V\" and i-2>=0:\r\n            variables.append(matrice(i-1, j ))\r\n            variables.append(matrice(i-2, j ))\r\n        elif matrice(i-3,j) != \"V\" and i-3>=0:\r\n            variables.append(matrice(i-1, j ))\r\n            variables.append(matrice(i-2, j ))\r\n            variables.append(matrice(i-3, j ))\r\n        else :\r\n            variables.append(matrice(i-1, j ))\r\n            variables.append(matrice(i-2, j ))\r\n            variables.append(matrice(i-3, j ))\r\n    else : # orientation == \"N\":\r\n        if i == n :\r\n            return\r\n        elif matrice(i+1,j) != \"V\" and i+1<=n :\r\n            variables.append(matrice(i+1,j))\r\n        elif matrice(i+2,j) != \"V\" and i+2<=n:\r\n            variables.append(matrice(i+1, j ))\r\n            variables.append(matrice(i+2, j ))\r\n        elif matrice(i+3,j) != \"V\" and i+3<=n:\r\n            variables.append(matrice(i+1, j ))\r\n            variables.append(matrice(i+2, j ))\r\n            variables.append(matrice(i+3, j ))\r\n        else :\r\n            variables.append(matrice(i+1, j ))\r\n            variables.append(matrice(i+2, j ))\r\n            variables.append(matrice(i+3, j ))\r\n    for elt in variables :\r\n        r.append(dict_var_to_num[elt])\r\n    return r\r\n\r\n\r\ndef recup_var_G(list_cases,dict_var_to_num):\r\n    var = []\r\n    for i in list_cases:\r\n        #on recupere les variables du type 00_G mais pas 00_G_N\r\n        if i[-1] == \"G\" :\r\n            var.append(dict_var_to_num[i])\r\n\r\n    return var\r\n\r\ndef exactly_k(k: int, variables: List[PropositionnalVariable]) -> ClauseBase:\r\n    r: ClauseBase = []\r\n    for tab in combinations(variables, k+1):\r\n        r.append([-x for x in tab])\r\n    for tab in combinations(variables, len(variables)+1-k):\r\n        r.append([x for x in tab])\r\n    return r\r\n\r\ndef main():\r\n\r\n    pass\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/clause_dynamique.py b/clause_dynamique.py
--- a/clause_dynamique.py	(revision cf4635df895fe994cf0e2bf2d4d403baa181a4f4)
+++ b/clause_dynamique.py	(date 1684951757008)
@@ -4,7 +4,7 @@
 import subprocess
 from itertools import combinations
 
-from test_clause_hitman import *
+from contraintes import *
 Grid = List[List[int]]
 PropositionnalVariable = int
 Literal = int
@@ -64,7 +64,113 @@
         r.append(dict_var_to_num[elt])
     return exactly_k(k,r)
 
-def voir(i,j,m,n,orientation,matrice,dict_var_to_num) :
+# def recup_k(i,j,m,n, matrice,dict_var_to_num) : # ici (0,0) = coin inferieur gauche
+#     position_possibles = ["I_N","I_S","I_E","I_O","G_N","G_S","G_E","G_O"]
+#     k = 0
+#     if i == 0 :
+#         if j == 0 : # coin inférieur gauche
+#             for a, b in combinations([1,0],2) :
+#                 if (matrice[a][b] == "G" or matrice[a][b] == "I") :
+#                 if (matrice[a][b] in position_possibles ) :
+#                     k+= 1
+#                 variables.append(f"{a}{b}_P")
+#
+#         elif j == m : # coin inférieur droit
+#             for a in range(0,1) :
+#                 for b in range(m-1,m) :
+#                     if (matrice[a][b] == "G" or matrice[a][b] == "I"):
+#                     if (matrice[a][b] in position_possibles):
+#                         k += 1
+#                     variables.append(f"{a}{b}_P")
+#
+#         else :
+#             for a in range(0,1) :
+#                 for b in range(j-1,j+1) :
+#                     if (matrice[a][b] == "G" or matrice[a][b] == "I"):
+#                     if (matrice[a][b] in position_possibles):
+#                         k += 1
+#                     variables.append(f"{a}{b}_P")
+#
+#     elif i == n :
+#         if j == 0 :  # coin supérieur gauche
+#             for a in range(n-1,n) :
+#                 for b in range(0,1) :
+#                     if (matrice[a][b] == "G" or matrice[a][b] == "I"):
+#                     if (matrice[a][b] in position_possibles):
+#                         k += 1
+#                     variables.append(f"{a}{b}_P")
+#
+#         elif j == m : # coin supérieur droit
+#             for a in range(n-1,n) :
+#                 for b in range(m-1,m) :
+#                     if (matrice[a][b] == "G" or matrice[a][b] == "I"):
+#                     if (matrice[a][b] in position_possibles):
+#                         k += 1
+#                     variables.append(f"{a}{b}_P")
+#         else :
+#             for a in range(n-1,n) :
+#                 for b in range(j-1,j+1) :
+#                     if (matrice[a][b] == "G" or matrice[a][b] == "I"):
+#                     if (matrice[a][b] in position_possibles):
+#                         k += 1
+#                     variables.append(f"{a}{b}_P")
+#     else :
+#         for a in range(i-1, i+1):
+#             for b in range(j - 1, j + 1):
+#                 if (matrice[a][b] == "G" or matrice[a][b] == "I"):
+#                 if (matrice[a][b] in position_possibles ) :
+#                     k += 1
+#
+#     return k
+
+
+def entendre(i,j,m,n,matrice,dict_var_to_num) :
+    k = recup_k(i,j,m,n,matrice,dict_var_to_num) # VA DEVENIR L'ARBITRE
+    if k>= 5  : return
+    r = []
+    variables = []
+    if i == 0:
+        if j == 0:  # coin inférieur gauche
+            for a in range(0, 1):
+                for b in range(0, 1):
+                    variables.append(f"{a}{b}_P")
+        elif j == m:  # coin inférieur droit
+            for a in range(0, 1):
+                for b in range(m - 1, m):
+                    variables.append(f"{a}{b}_P")
+        else:
+            for a in range(0, 1):
+                for b in range(j - 1, j + 1):
+                    variables.append(f"{a}{b}_P")
+
+    elif i == n:
+        if j == 0:  # coin supérieur gauche
+            for a in range(n - 1, n):
+                for b in range(0, 1):
+                    variables.append(f"{a}{b}_P")
+
+        elif j == m:  # coin supérieur droit
+            for a in range(n - 1, n):
+                for b in range(m - 1, m):
+                    variables.append(f"{a}{b}_P")
+        else:
+            for a in range(n - 1, n):
+                for b in range(j - 1, j + 1):
+                    variables.append(f"{a}{b}_P")
+    else:
+        for a in range(i - 1, i + 1):
+            for b in range(j - 1, j + 1):
+                variables.append(f"{a}{b}_P")
+
+    for elt in variables :
+        r.append(dict_var_to_num[elt])
+    if k >= 5:
+        return at_least_k(5,r)
+
+    return exactly_k(k,r)
+
+
+def voir_V1(i,j,m,n,orientation,matrice,dict_var_to_num) : # Voir comme on l'avait pensé au début
     r = []
     variables = []
     if orientation == "E"  :
@@ -135,6 +241,34 @@
         r.append(dict_var_to_num[elt])
     return r
 
+def voir_V2(liste) : # Voir comme on le pense maintenant
+    variables = []
+    for elt in liste :
+        variables.append(dict_var_to_num[elt])
+    return variables
+
+def tourner_droite(orientation) : # sens horaire
+    if orientation == "E" :
+        return "S"
+    if orientation == "S" :
+        return "O"
+    if orientation == "O" :
+        return "N"
+    if orientation == "N" :
+        return "E"
+
+def tourner_gauche(orientation) : # sens anti-horaire
+    if orientation == "E" :
+        return "N"
+    if orientation == "S" :
+        return "E"
+    if orientation == "O" :
+        return "S"
+    if orientation == "N" :
+        return "O"
+
+def avancer(i, j,orientation,liste) :
+
 
 def recup_var_G(list_cases,dict_var_to_num):
     var = []
@@ -145,13 +279,6 @@
 
     return var
 
-def exactly_k(k: int, variables: List[PropositionnalVariable]) -> ClauseBase:
-    r: ClauseBase = []
-    for tab in combinations(variables, k+1):
-        r.append([-x for x in tab])
-    for tab in combinations(variables, len(variables)+1-k):
-        r.append([x for x in tab])
-    return r
 
 def main():
 
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n.vscode/settings.json\r\ngophersat.exe\r\n*.pyc\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	(revision cf4635df895fe994cf0e2bf2d4d403baa181a4f4)
+++ b/.gitignore	(date 1684951757022)
@@ -2,3 +2,9 @@
 .vscode/settings.json
 gophersat.exe
 *.pyc
+.idea/IA02-HITMAN.iml
+.idea/inspectionProfiles/profiles_settings.xml
+.idea/inspectionProfiles/Project_Default.xml
+.idea/modules.xml
+.idea/vcs.xml
+.idea/misc.xml
\ No newline at end of file
Index: verite_sur_le_monde.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from pprint import pprint\r\nfrom time import sleep\r\nfrom typing import List, Tuple\r\nimport subprocess\r\nfrom itertools import combinations\r\n\r\nfrom test_clause_hitman import *\r\nfrom affichage import *\r\n\r\nGrid = List[List[int]]\r\nPropositionnalVariable = int\r\nLiteral = int\r\nClause = List[Literal]\r\nClauseBase = List[Clause]\r\nModel = List[Literal]\r\n\r\n\r\ndef recup_var_G(list_cases,dict_var_to_num):\r\n    var = []\r\n    for i in list_cases:\r\n        #on recupere les variables du type 00_G mais pas 00_G_N\r\n        if i[-1] == \"G\" :\r\n            var.append(dict_var_to_num[i])\r\n\r\n    return var\r\ndef gen_var_lettre(m,n,dict_var_to_num,lettre : str):\r\n    var = []\r\n    for i in range(m):\r\n        for j in range(n):\r\n            var.append(dict_var_to_num[f\"{i}{j}_{lettre}\"])\r\n    return var\r\n\r\ndef gen_var_par_case(m,n,list_cases,dict_var_to_num, sauf :list[str] =[\"P\",\"G\",\"I\"]):\r\n    # {\"00\": [\"00_V\",\"00_M\",\"00_C\",...,\"00_G_O\"]\r\n    #  \"01\": [\"01_V\",...,\"01_G_O\"]\r\n    #  ...}\r\n    dico_var_par_case = {}\r\n    for i in range(m):\r\n        for j in range(n):\r\n            dico_var_par_case[f\"{i}{j}\"] = []\r\n    \r\n    for k in list_cases:\r\n        if k[-1] not in sauf:\r\n            dico_var_par_case[k[:2]].append(dict_var_to_num[k])\r\n    return dico_var_par_case \r\n\r\n#00_P<-> 00_Gou 00_i  : (-00_P ou 00_G ou 00_I ) et (-00_G ou 00_P) et (-00_I  ou 00_P)\r\ndef gen_clause_P_equi_G_ou_I(m,n,dict_var_to_num):\r\n    r: ClauseBase = []\r\n    #on genere les variables\r\n    var_P = gen_var_lettre(m,n,dict_var_to_num,\"P\")\r\n    var_G = gen_var_lettre(m,n,dict_var_to_num,\"G\")\r\n    var_I = gen_var_lettre(m,n,dict_var_to_num,\"I\")\r\n    for i in range(len(var_P)):\r\n        r.append([-var_P[i],var_G[i],var_I[i]])\r\n        r.append([-var_G[i],var_P[i]])\r\n        r.append([-var_I[i],var_P[i]])\r\n    return r\r\n\r\ndef gen_clause_lettre_equi_lettre_orientation(m,n,dict_var_to_num,lettre : str):\r\n    r: ClauseBase = []\r\n    #on genere les variables\r\n    var_l = gen_var_lettre(m,n,dict_var_to_num,f\"{lettre}\")\r\n    var_l_N = gen_var_lettre(m,n,dict_var_to_num,f\"{lettre}_N\")\r\n    var_l_S = gen_var_lettre(m,n,dict_var_to_num,f\"{lettre}_S\")\r\n    var_l_E = gen_var_lettre(m,n,dict_var_to_num,f\"{lettre}_E\")\r\n    var_l_O = gen_var_lettre(m,n,dict_var_to_num,f\"{lettre}_O\")\r\n    for i in range(len(var_l)):\r\n        r.append([-var_l[i],var_l_N[i],var_l_S[i],var_l_E[i],var_l_O[i]])\r\n        r.append([-var_l_N[i],var_l[i]])\r\n        r.append([-var_l_S[i],var_l[i]])\r\n        r.append([-var_l_E[i],var_l[i]])\r\n        r.append([-var_l_O[i],var_l[i]])\r\n    return r\r\n\r\ndef exactly_k(k: int, variables: List[PropositionnalVariable]) -> ClauseBase:\r\n    r: ClauseBase = []\r\n    for tab in combinations(variables, k+1):\r\n        r.append([-x for x in tab])\r\n    for tab in combinations(variables, len(variables)+1-k):\r\n        r.append([x for x in tab])\r\n    return r\r\n\r\n#Écrire une fonction clauses_to_dimacs(clauses: ClauseBase, nb_vars: int) -> str qui,\r\n#étant donné une base de clauses et le nombre de variables à considérer, renvoie une\r\n#chaîne de caractères codant la base de clauses au format Dimacs.\r\n#>>> clauses_to_dimacs([[-1, -2], [1, 2], [1, 3], [2, 4], [-3, 4], [-4, 5]], 5)\r\n#'p cnf 5 6\\n-1 -2 0\\n1 2 0\\n1 3 0\\n2 4 0\\n-3 4 0\\n-4 5 0\\n'\r\n\r\ndef clauses_to_dimacs(clauses: ClauseBase, nb_vars: int) -> str:\r\n    r = f\"p cnf {nb_vars} {len(clauses)}\\n\"\r\n    for clause in clauses:\r\n        for literal in clause:\r\n            r += f\"{literal} \"\r\n        r += \"0\\n\"\r\n    return r\r\n\r\n\r\n\r\n\r\ndef main():\r\n    list_var = creer_list_var(5,8)\r\n    dico_var_to_num = creer_dictionnaire_cases_par_list(list_var)\r\n\r\n    #on recupere les variables\r\n    var_Guarde =  gen_var_lettre(5,8,dico_var_to_num,\"G\")\r\n    var_Target =  gen_var_lettre(5,8,dico_var_to_num,\"T\")\r\n    var_Invite =  gen_var_lettre(5,8,dico_var_to_num,\"I\")\r\n    var_Corde  =  gen_var_lettre(5,8,dico_var_to_num,\"C\")\r\n    dico_par_case = gen_var_par_case(5,8,list_var,dico_var_to_num)\r\n\r\n\r\n    #on genere les clauses\r\n    V_sur_le_monde : ClauseBase = []\r\n    V_sur_le_monde += exactly_k(2,var_Guarde)\r\n    V_sur_le_monde += exactly_k(3,var_Invite)\r\n    V_sur_le_monde += exactly_k(1,var_Target)\r\n    V_sur_le_monde += exactly_k(1,var_Corde)\r\n    for i in dico_par_case:\r\n        V_sur_le_monde += exactly_k(1,dico_par_case[i])\r\n\r\n    V_sur_le_monde += gen_clause_P_equi_G_ou_I(5,8,dico_var_to_num)\r\n    V_sur_le_monde += gen_clause_lettre_equi_lettre_orientation(5,8,dico_var_to_num,\"G\")\r\n    V_sur_le_monde += gen_clause_lettre_equi_lettre_orientation(5,8,dico_var_to_num,\"I\")\r\n\r\n    print(len(list_var))\r\n    print(len(V_sur_le_monde))\r\n\r\n    dimac = clauses_to_dimacs(V_sur_le_monde,len(list_var))\r\n    #print(dimac)\r\n    write_dimacs_file(dimac, \"./test.cnf\")\r\n    res = exec_gophersat( \"test.cnf\")\r\n    \r\n    print(res)\r\n    model_to_grid(res[1],5,8,list_var)\r\n\r\n    pass\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/verite_sur_le_monde.py b/verite_sur_le_monde.py
--- a/verite_sur_le_monde.py	(revision cf4635df895fe994cf0e2bf2d4d403baa181a4f4)
+++ b/verite_sur_le_monde.py	(date 1684951757041)
@@ -4,7 +4,7 @@
 import subprocess
 from itertools import combinations
 
-from test_clause_hitman import *
+from contraintes import *
 from affichage import *
 
 Grid = List[List[int]]
@@ -73,13 +73,7 @@
         r.append([-var_l_O[i],var_l[i]])
     return r
 
-def exactly_k(k: int, variables: List[PropositionnalVariable]) -> ClauseBase:
-    r: ClauseBase = []
-    for tab in combinations(variables, k+1):
-        r.append([-x for x in tab])
-    for tab in combinations(variables, len(variables)+1-k):
-        r.append([x for x in tab])
-    return r
+
 
 #Écrire une fonction clauses_to_dimacs(clauses: ClauseBase, nb_vars: int) -> str qui,
 #étant donné une base de clauses et le nombre de variables à considérer, renvoie une
Index: contraintes.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/contraintes.py b/contraintes.py
new file mode 100644
--- /dev/null	(date 1684951757052)
+++ b/contraintes.py	(date 1684951757052)
@@ -0,0 +1,29 @@
+from pprint import pprint
+from time import sleep
+from typing import List, Tuple
+import subprocess
+from itertools import combinations
+Grid = List[List[int]]
+PropositionnalVariable = int
+Literal = int
+Clause = List[Literal]
+ClauseBase = List[Clause]
+Model = List[Literal]
+
+
+def exactly_k(k: int, variables: List[PropositionnalVariable]) -> ClauseBase:
+    r: ClauseBase = []
+    for tab in combinations(variables, k+1):
+        r.append([-x for x in tab])
+    for tab in combinations(variables, len(variables)+1-k):
+        r.append([x for x in tab])
+    return r
+
+
+
+#retourne l'ensemble de clause traitant la contrainte : "au moins n variables vraies dans la liste"
+def at_least_k(k: int, variables: List[PropositionnalVariable]) -> ClauseBase:
+    r: ClauseBase = []
+    for tab in combinations(variables, len(variables)+1-k):
+        r.append([x for x in tab])
+    return r
\ No newline at end of file
Index: test_clause_hitman.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from pprint import pprint\r\nfrom time import sleep\r\nfrom typing import List, Tuple\r\nimport subprocess\r\nfrom itertools import combinations\r\nGrid = List[List[int]]\r\nPropositionnalVariable = int\r\nLiteral = int\r\nClause = List[Literal]\r\nClauseBase = List[Clause]\r\nModel = List[Literal]\r\n\r\n#map m*n de taille\r\n\r\n\r\n#vide \t\t\t\t\tV\r\n#mur \t\t\t\t\tM\r\n#corde de piano \t\tC\r\n#costume deguisement \tD\r\n#cible \t\t\t\t\tT\r\n#invité (N/S/E/O)\t\tI\r\n#garde (N/S/E/O)\t\tG\r\n\r\n#variable du type\r\n#position__type_orientation\r\n#00_V\r\n#00_I_N\r\n\r\n\r\n# [\"00_V\",\"00_M\",\"00_C\",...,\"00_G_O\",\"01_V\",...,\"58_G_O\"]\r\ndef creer_list_var(m,n):\r\n    list_cases = []\r\n    for i in range(0,m):\r\n        for j in range(0,n):\r\n            for reste in [\"V\",\"M\",\"C\",\"D\",\"T\",\"I\",\"I_N\",\"I_S\",\"I_E\",\"I_O\",\"G\",\"G_N\",\"G_S\",\"G_E\",\"G_O\",\"P\"]:\r\n                list_cases.append(\"%d%d_%s\"%(i,j,reste))\r\n    return list_cases\r\n\r\n\r\ndef creer_dictionnaire_cases_par_list(list_variable):\r\n    # Création du dictionnaire une variable = un chiffre:\r\n    compteur = 1\r\n    dict_cases = {}\r\n    for i in list_variable:\r\n        dict_cases[i] = compteur\r\n        compteur += 1\r\n    return dict_cases\r\n\r\n#### fonctions fournies\r\n\r\ndef write_dimacs_file(dimacs: str, filename: str):\r\n    with open(filename, \"w\", newline=\"\") as cnf:\r\n        cnf.write(dimacs)\r\n\r\ndef exec_gophersat(\r\n    filename: str, cmd: str = \"gophersat\", encoding: str = \"utf8\"\r\n) -> Tuple[bool, List[int]]:\r\n    result = subprocess.run(\r\n        [cmd, filename], capture_output=True, check=True, encoding=encoding\r\n    )\r\n    string = str(result.stdout)\r\n    lines = string.splitlines()\r\n\r\n\r\n    if lines[1] != \"s SATISFIABLE\":\r\n        return False, []\r\n\r\n\r\n    model = lines[2][2:-2].split(\" \")\r\n\r\n\r\n    return True, [int(x) for x in model]\r\n\r\n\r\n#clause verité sur le monde\r\n\r\ndef recup_var_G(list_cases,dict_var_to_num):\r\n    var = []\r\n    for i in list_cases:\r\n        #on recupere les variables du type 00_G mais pas 00_G_N\r\n        if i[-1] == \"G\" :\r\n            var.append(dict_var_to_num[i])\r\n\r\n    return var\r\n\r\ndef exactly_k(k: int, variables: List[PropositionnalVariable]) -> ClauseBase:\r\n    r: ClauseBase = []\r\n    for tab in combinations(variables, k+1):\r\n        r.append([-x for x in tab])\r\n    for tab in combinations(variables, len(variables)+1-k):\r\n        r.append([x for x in tab])\r\n    return r\r\n\r\ndef main():\r\n    \r\n\r\n    \r\n    pass\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test_clause_hitman.py b/test_clause_hitman.py
--- a/test_clause_hitman.py	(revision cf4635df895fe994cf0e2bf2d4d403baa181a4f4)
+++ b/test_clause_hitman.py	(date 1684951757049)
@@ -83,13 +83,7 @@
 
     return var
 
-def exactly_k(k: int, variables: List[PropositionnalVariable]) -> ClauseBase:
-    r: ClauseBase = []
-    for tab in combinations(variables, k+1):
-        r.append([-x for x in tab])
-    for tab in combinations(variables, len(variables)+1-k):
-        r.append([x for x in tab])
-    return r
+
 
 def main():
     
